# Java学习笔记

第一章：[概述](#1)

第二章：[Java代码规则与规范](#2)

第三章：[变量](#3)

第四章：[运算符](#4)

第五章：[程序控制结构](#5)

第六章：[数组、排序、查找](#6)

第七章：[面向对象编程(初级)](#7)

第八章：[面向对象编程(中级)](#8)

第九章：[房屋租赁系统](#9)

第十章：[面向对象编程(高级)](#10)

第十一章：[枚举和注解](#11)

第十二章：[异常(Exception)](#12)

第十三章：[常用类](#13)



<p id="13"></p>



### 第十三章：常用类

#### &sect;1.包装类（Wrapper）

**一、分类**

1、针对八种基本数据类型相应的引用类型——包装类

2、有了类的特点，就可以调用类中方法

|  基本数据类型  |     包装类     |
| :------------: | :------------: |
|    boolean     |    Boolean     |
|      char      |   Character    |
|      byte      |      Byte      |
|     short      |     Short      |
|      int       |    Integer     |
|      long      |      Long      |
| float . double | Folat . Double |

注：除前两行外，其余均为Number的子类

**二、包装类和基本数据类型转换**

以int和Integer为例：

1、jdk5前手动装箱、拆箱。装箱指基本数据类型--》包装类型

2、jkd5以及以后的自动装箱、拆箱

3、其他包装类用法相似

**三、包装类和String类型相互转换**

1、包装类--》String

​	eg.Integer i = 100;

​		 String str1 = i+"";	//法1

​		 String str2 = i.toString();	//法2

​		 String str3 = String.valueOf(i);	//法3

2、String--》包装类

​	eg.String str = "123";

​		 Integer i2 = Integer.parseInt(str);	//法1

​		 Integer i3 = new Integer(str);	//法2

**四、Integer和Character类的常用方法**

1、Integer.MIN_VALUE	//返回最小值

​	  Integer.MAX_VALUE	//返回最大值

2、Character.isDigit('a');	//判断是否为数字

​	  Character.isLetter('a');	//判断是否为字母

​	  Character.isUpperCase('a');	//判断是否为大写

​	  Character.isLowerCase('a');	//判断是否为小写

​	  Character.isWhitespace('a');	//判断是否为空格

​	  Character.toUpperCase('a');	//转成大写

​	  Character.toLowerCase('A');	//转成小写

**五、Integer创建机制**

public void m1(){

​	Integer i = new Integer(1);

​	Integer j = new Integer(1);

​	sout...(i==j);	//false



​	Integer m = 1;	//底层是Integer.valueOf(1)

​	Integer n = 1;

​	sout...(m==n);	//true

​	//阅读源码可知，当值为-128—127时，不会创建新对象，其他值会new Integer



​	Integer x = 128;

​	Integer y = 128;

​	sout...(x==y);	//false

}

#### &sect;2.String类

**一、String类理解和创建对象**

1、String对象用于保存字符串

2、字符串常量对象是用双引号括起的字符序列

3、字符串字符使用Unicode字符编码，一个字符占两字节

4、字符串类常用构造器：

​	String s1 = new String();

​	String s2 = new String(String s);

​	String s3 = new String(char[] a);

​	String s4 = new String(char[] a,int startIndex,int count);

5、String类实现了接口Serializable（可串行化：可在网络传输）Comparable（可以相互比较大小）

6、String类是final类

7、创建：①String s = "hsp";

​				  ②String s = new String("hsp")

​		注：法①，先从常量池查看是否有“hsp”空间，若有，直接指向；若没有，则重新创建，再指向。s最终指向的是常量池空间地址

​				法②，先在堆中创建空间，里面维护value属性，指向常量池的hsp空间。若常量池没有“hsp”，重新创建，若有，直接通过value		指向，最终指向堆中空间地址

​		③内存图

​		![hadoop](https://github.com/Vincy-w/my_java_study/raw/main/picture/String内存.png)

**二、字符串的特性**

1、String是一个final类，代表不可变的字符序列

2、字符串是不可变的，一个字符串对象一旦被分配，其内容是不可变的

​	eg1.String s1 = "hello";

​			s1 = "haha";

​	![hadoop](https://github.com/Vincy-w/my_java_study/blob/main/picture/String改变.png)

​	eg2.String  a = "hello" + "abc";

​			//编译器会优化为String a = "helloabc"

​	eg3.String a = "hello";

​			String b = "abc";

​			String c = a+b;

​			/*

​				1.先创建StringBuilder sb = StringBuilder()

​				2.执行sb.append("hello")

​				3.sb.append("abc")

​				4.String c = sb.toString()

​			*/

​			内存示意：

​			![hadoop](https://github.com/Vincy-w/my_java_study/blob/main/picture/String内存-3.png)

**三、String类常见方法**

1、说明：String类是保存字符串常量的。每次更新都须重新开辟空间，效率较低，因此java设计者提供了String Builder和StringBuffer来增强String功能，并提高效率

2、实例1

​	equals	//区分大小写，判断内容是否相等

​	equalsIgnoreCase	//忽略大小写的判断内容是否相同

​	length	//获取字符个数

​	indexOf	//获取字符在字符串中第一次出现的索引，若没有，返回-1

​	lastIndexOf	//获取字符在字符串中最后一次出现的索引，若没有，返回-1

​	substring	//截取指定范围的子串

​	trim	//去前后空格

​	charAt	//获取某索引处的字符，不能用str[index]取字符

3、实例2

​	replace	//替换字符串中字符

​	split	//分割字符串，对某些分割字符，须转义，如“|、\\\”等

​	compareTo	//比较两字符串大小

​	toCharArray	//转换成字符数组

​	format	//格式字符串，%s字符串，%c字符，%d整型，%2f浮点型（%-称为占位符，由后面变量来替换）

​	toUpperCase	//转成大写

​	toLowerCase	//转成小写

​	concat	//拼接字符串

#### &sect;3.StringBuffer类

**一、介绍**

1、java.lang.StringBuffer代表可变字符序列，可对字符串内容进行增删

2、很多方法与String相同，但StringBuffer可变长度

3、StringBuffer是一个容器

**二、String VS StringBuffer**

1、String保存的是字符串常量，里面的值不能修改，每次String类的更新实际上是更改地址、效率低

2、StringBuffer存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可更新内容，不用每次更新地址，效率更高

//char[] value 放在堆

**三、StringBuffer构造器**

1、StringBuffer()

​	构造一个其中不带字符的字符串缓冲区，初始容量16

2、StringBuffer(CharSequence seq)

​	构造一个字符串缓冲区，包含与指定CharSequence相同的字符

3、StringBuffer(int capcity)

​	构造一个不带字符，但具有指定初始容量的字符串缓冲区

4、StringBuffer(String str)

​	构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容，长度为str.length()+16

**四、String和StringBuffer相互转换**

1、String->StringBuffer

​	String s = "hello";

​	①StringBuffer b1 = new StringBuffer(s);

​	②StringBuffer b2 = new StringBuffer(); b2.append(s);

2、StringBuffer- >String

​	StringBuffer b3 = new StringBuffer("hspedu");

​	①String s = b3.toString();

​	②String s = new String(b3);

**五、StringBuffer类常见的方法**

1、增 append（）

2、删 delete（start，end）//删[start,end)间字符

3、改 replace(start,end,string)	//替换

4、查 indexOf	//查找子串第一次出现的位置，若无，则返回-1

5、插 insert(index,"...")

6、获取长度 length

#### &sect;4.StringBuilder类

**一、介绍**

1、一个可变字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。若可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer快

2、在StringBuilder上主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据

**二、常用方法**

参考StringBuffer

**三、String、StringBuffer、StringBuilder比较**

1、StringBuilder和StringBuffer非常类似，均代表可变字符序列，且方法一样

2、String：不可变字符序列，效率低，但复用率高

3、StringBuffer：可变字符序列，效率较高，线程安全

4、StringBuilder：可变字符序列，效率最高，线程不安全

5、String使用注意：若对String做大量修改，则不要使用String

**四、使用原则**

1、若字符串存在大量修改操作，一般用StringBuffer或StringBuilder

2、若字符串很少修改，被多个对象引用，用String

#### &sect;5.Math类

**一、介绍**

Math类包含用于执行基本数学运算的方法，如初等指数，对数，平方根和三角函数

**二、常用方法**

1、abs 绝对值

2、random 求随机数

……

#### &sect;6.Arrays类

**一、常见方法**

1、toString返回数组的字符串形式

​	Arrays.toString(arr);

2、sort排序（自然排序、定制排序）

​	①直接使用sort传入数组，即可实现由小到大排序

​	②也可以通过传入一个Comparator接口实现定制排序。调用时，传入排序数组arr和实现了Comparator接口的匿名内部类

3、binarySearch通过二分搜索法进行查找，要求必须排好序（升序）

4、copyOf数组元素的复制

​	Integer[] newArr = Arrays.copyOf(arr,arr.length);

5、fill数组元素的填充

​	Integer[] num = new Integer[]{9,3,2};

​	Array.fill(num,99);

​	//用指定数将数组内所有数替换

6、equals.比较两数组元素内容是否完全一致

​	boolean equals = Arrays.equals(arr1,arr2);

7、asList将一组值，转换成list

​	`List<Integer> asList = Arrays.asList(2,6,1);`

​	`sout...("asList="+asList);`

​	//asList方法将数组转成一个List集合，运行类型是Arrays类的静态内部类ArrayList

#### &sect;7.System类

**一、常见方法**

1、exit 退出当前程序

2、arraycopy 复制数组元素，比较适合底层调用，一般使用Array.copyOf完成复制数组

3、currentTimeMillens 返回当前时间距离，1970-1-1至今的毫米数

4、gc 运行垃圾回收机制

#### &sect;8.BigInteger和BigDecimal类

**一、介绍**

1、应用场景

​	①BigInteger适合保存较大的整型

​	②BigDecimal适合精度更高的浮点型

2、加减乘除时须使用相应方法：add,substract,multiply,divide

3、构建对象时，需用字符串

​	eg.BigInteger b1 = new BigInteger("99999999999");

4、BigDecimal在调用divide可能出现无限小数，抛出异常，可以指定精度

​	eg.bigDecimal.divide(bigDecimal2,BigDecimal.ROUND_CEILING);//与分子精度相同

#### &sect;9.日期类

**一、第一代日期类**

1、Date：精确到毫秒，代表特定瞬间

2、SimpleDateFormat：格式和解析日期的类。允许进行格式化（日期-》文本），解析（文本-》日期）和规范化

3、这里的Date类在Java.util包中

4、创建SimpleDateFormat对象，可指定相应格式有固定规则

5、可以将格式化的String转成对应Date，SimpleDateFormat.parse(str);

**二、第二代日期类**

1、主要指Calendar类

2、Calendar类是一个抽象类

3、创建对象：Calendar c = Calendar.getInstance();//不能new

4、获取日历对象某字段

​	c.get(Calendar.YEAR)

​	c.get(Calendar.MONTH)+1;//月份按从0编号，故+1

​	c.get(Calendar.HOUR)

**三、第三代日期类**

1、前两代的不足

​	①可变性：日期和时间这样的类应是不可变的

​	②偏移性：Date中年份从1900开始，月份都从0开始

​	③格式化：只对Date有用，Calendar不行

​	④不是线程安全的，不能处理闰秒

2、常见方法

​	①LocalDate（日期/年月日）、LocalTime（时间/时分秒）、LocalDateTime（日期时间）

​	②DateTimeFormatter格式日期类

​		eg.DateTimeFormatter dtf = DateTimeFormatter.ofPattern(格式)；

​			 String str = dtf.format(日期对象)；

​	③Instant时间戳

​		Instant-》Date

​		Date d = Date.from(instant)

​		Date->Instant

​		Instant ins = date.toInstant();

​	④plus和minus可对当前时间进行加或减

​		eg.LocalDateTime ldt = now.plusDays(int);



<p id="12"></p>



### 第十二章：异常(Exception)

#### &sect;1.异常的概念

**一、语法**

选中可能出现异常的代码块，ctrl+alt+t，选中try-catch，即使出现异常，程序仍可继续进行

**二、概念**

Java语言中，将程序执行中发生的不正常情况称为“异常”（语法错误和逻辑错误不是异常）

**三、分类**

1、Error：Java虚拟机无法解决的严重问题，如：JVM系统内部错误，资源耗尽等。ERROR是严重错误，程序会崩溃

2、Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可使用针对性代码进行处理。如空指针访问，试图读取不存在的文件，网络连接中断等。Exception分为两大类：运行时异常（程序运行时，发生的异常）和编译时异常（编程时，编译器检测出的异常）

#### &sect;2.异常体系图

**一、图览**

![hadoop](https://github.com/Vincy-w/my_java_study/raw/main/picture/异常体系.png)

#### &sect;3.常见的异常

**一、常见的运行异常**

1、NullPointerException空指针异常

​	当应用程序试图在需要对象的地方使用null时，会抛出异常

2、ArithmeticException数学运算异常

​	当出现异常的运算条件时，抛出异常。如，除数为零

3、ArrayIndexOutOfBoundsException数组下标越界异常

​	用非法索引访问数组时抛出的异常。若索引为负或大于等于数组大小，则该索引非法。

4、ClassCastException类型转换异常

​	当试图将对象强制转换为不是实例的子类时，抛出该异常

5、NumberFormatException数字格式不正确异常

​	当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适用格式时，抛出该异常 =》使用异常可确保输入是满足条件数字

**二、常见的编译异常**

（编译期间，就必须处理的异常，否则代码不能通过编译）

SQLException	//操作数据库时，查询表可能发生异常

IOException	//操作文件时，发生的异常

FileNotFoundException	//当操作一个不存在的文件时，发生异常

ClassNotFoundException	//加载类，而类不存在时，异常

EOFException	//操作文件，到文件末尾，发生异常

IllegalArgumentException	//参数异常

#### &sect;4.异常处理

**一、介绍**

异常处理是当异常发生时，对异常处理的方式

**二、处理方式**

1、try-catch-finally

​	程序员在代码中捕获发生的异常，自行处理

2、throws

​	将发生的异常抛出，交给调用者（方法）来处理，最顶级处理者是JVM

**三、示意图**

1、try-catch-finally	//快捷键ctrl+alt+t

​	try{

​		代码//可能有异常

​	}catch(Exception e){	//若无异常，则catch不执行。系统将异常信息封装成e，传给catch，得到异常后，程序员处理

​		e.getMessage();	//捕获异常。

​	}finally{

​	//不管try是否有异常，始终执行finally，一般将释放资源代码置于此

​	}

2、throws

![hadoop](https://github.com/Vincy-w/my_java_study/raw/main/picture/throws.png)

注：try-catch-finally和throws二选一使用。若没有try-catch，则默认使用throws

**四、try-catch方式处理异常说明**

1、Java提供try和catch块处理异常。try块用于包含可能出错的代码。catch块用于处理try块中发生的异常。可根据需要在程序中设多个try-catch块

2、注意事项

​	①若异常发生，则异常发生后面的代码不会执行，直接进入到catch块

​	②若异常未发生，则顺序执行try代码块，不会进入catch

​	③可有多个catch语句，捕获不同的异常，进行不同的业务处理。要求父类异常在后，子类异常在前，若发生异常，只会匹配一个catch

​	eg.try{

​		 }catch(NullPointerException e){

​		 }catch(Exception e){

​		 }

​	④可进行try-finally配合使用，此用法相当于没有捕获异常，因此程序直接退出/崩掉。应用场景：不管是否发生异常，都必须执行某业务逻辑。

**五、throws异常处理**

1、介绍

​	①若一方法可能生成某种异常，但并不能确定如何处理。则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由方法调用者负责。

​	②在方法声明中用throws语句可声明抛出异常的列表，throws后的异常类型可以是方法中产生的异常类型，也可以是他的父类。

2、使用细节

​	①对于编译异常，程序中必须处理。throws和try-catch均可

​	②对运行异常，程序中未处理，默认使用throws

​	③子类重写父类方法时，对抛出异常的规定：子类重写的方法，所抛出的异常要么和父类一致，要么为父类抛出异常类型的子类。

#### &sect;5.自定义异常

**一、概念**

当程序中出现某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息

**二、步骤**

1、定义类：自定义异常类名（程序员自己设）继承Exception或RuntimeException

2、若继承Exception，属编译异常

3、若继承RuntimeException，属运行异常

#### &sect;6.throw和throws的区别

**一、概述**

|        |           意义           |    位置    | 后面内容 |
| :----: | :----------------------: | :--------: | :------: |
| throws |    异常处理是一种方式    | 方法声明处 | 异常类型 |
| throw  | 手动生成异常对象的关键字 |  方法体中  | 异常对象 |



<p id="11"></p>



### 第十一章：枚举和注解

#### &sect;1.枚举

**一、介绍**

枚举（enumeration，简写enum），枚举是一组常量的集合

**二、实现方式**

1、自定义类实现枚举

​	①构造器私有化

​	②不提供setXX方法

​	③对枚举对象使用final+static+public共同修饰，在类的内部创建

​	④枚举对象名通常全大写

2、使用enum关键字实现枚举

​	①使用enum替代class

​	②常量名（实参列表）

​	③若有多个常量，使用逗号间隔

​	④enum中要求将定义的常量对象写在最前面

**三、注意事项**

1、当使用enum关键字时，默认会继承Enum类，且是一个final类

2、若使用无参构造器创建常量对象，则可省略（）

**四、enum常用方法**

1、toString:返回当前对象名，子类可重写，用于返回属性

2、name:返回当前常量名，不可重写

3、ordinal:返回当前对象位置号，默认从0开始

4、values:返回当前枚举类中所有常量

5、valueOf:将字符串转为枚举对象，要求字符串须为已有常量名

6、compareTo:比较两枚举常量的位置号，返回编号差

**五、细节**

1、enum已继承Enum故不能再继承其他类

2、枚举类和普通类一样，可实现接口

#### &sect;2.注解

**一、介绍**

1、注解（Annotation）也被称为元数据（Metadata）用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。

2、和注释一样，注解不影响程序逻辑，但注解可被编译或运行，相当于在代码中嵌入补充信息

3、在JavaSE中，注解的使用目的简单，如标记过时的功能，忽略警告等。在JavaEE中注解占据更重要的角色，如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置

**二、基本注解介绍**

使用Annotation时要在其前面加@符，并把Annotation当成一个修饰符使用。用于修饰它支持的程序元素

1、@override:限定某个方法，是重写父类的方法

2、@Deprecated:用于表示某程序元素（类、方法...）已过时

3、@SuppressWarnings:抑制编译器警告

​	eg.@SuppressWarnings({"all"})

#### &sect;3.元注解

JDK的元注解用于修饰其他注解



<p id="10"></p>



### 第十章：面向对象编程（高级）

#### &sect;1.类变量和类方法

**一、类变量内存布局**

![hadoop](https://github.com/Vincy-w/my_java_study/raw/main/picture/类变量.png)

注：1、static变量是本类所有对象共享的

​		2、static变量是在本类加载时生成的

**二、概念**

1、类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个。

2、定义语法

​	访问修饰符 static 数据类型 变量名；（常用）

​	static 访问修饰符 数据类型 变量名；

3、访问

​	类名.类变量名（常用）

​	对象名.类变量名

**三、细节**

1、类变量与实例变量（普通属性）区别

​	类变量是该类所有对象共享的，而实例变量是每个对象独享的

2、类变量在类加载时便初始化了。即，即便没有创建对象，只要类加载了，就可以使用类变量。

**四、类方法**

1、基本介绍：访问修饰符 static 返回类型 方法名（）{}

2、调用：类名/对象名.方法名

3、使用场景：

​	①当方法中不涉及任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率

​	②实际开发中，将一些通用方法，设计成静态方法，如打印一维数组，冒泡排序...

4、使用细节

​	①类方法中无this参数，也没有super

​	②普通方法不通过类名访问

​	③类方法只能访问静态变量或静态方法

​	④普通成员方法，既可以访问非静态成员，也可以访问静态成员

#### &sect;2.理解main方法语句

**一、深入理解main方法**

1、main方法是虚拟机调用

2、java虚拟机须调用类的main()方法，所有必须为public

3、java虚拟机在执行main()方法时不必创建对象，故该方法为static

4、该方法接收string类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数

5、如何在IDEA中传入参数：

​	Edit Configurations => Configuration => Program arguments中直接输入 => Apply

#### &sect;3.代码块

**一、基本介绍**

​	代码块又称初始化块，属于类中的一部分，类似于方法，将逻辑语句封装在方法体中，通过{}包起来。

​	但和方法不同，没有方法名，没有返回，没有参数，只有方法体，不通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。

**二、基本语法**

修饰符{

​	代码

}；

注：①修饰符可选，只能为static或无

​		②用static修饰叫静态代码块；没有的，叫普通代码块

​		③逻辑语句可以为任何逻辑语句

​		④；可写可不写

**三、好处**

1、相当于另一种形式的构造器，可做初始化操作

2、若多个构造器都有重复语句，可抽取到初始化块中，提高代码重用性。

**四、使用细节**

1、static代码块也叫静态代码块，作用是对类进行初始化，且它随着类的加载而执行，且只会执行一次。普通代码块，每创建一个对象，就执行。

2、类何时被加载（只会加载一次）<font style=background:red>&spades;&spades;</font>

​	①创建对象实例时（new）

​	②创建子类对象实例时，父类也会被加载

​	③使用类的静态成员时

3、创建对象时，在一个类中调用顺序如下：<font style=background:red>&spades;&spades;</font>

​	①调用静态代码块和静态属性初始化。//按定义顺序调用，优先级一样

​	②调用普通代码块和普通属性初始化。//按定义顺序调用，优先级一样

​	③调用构造方法

4、构造器的最前面隐含了super()和调用普通代码块，静态相关的代码块、属性初始化在类加载时就已完成。

5、继承关系存在时，创建子类调用顺序如下：

​	①父类的静态代码块和静态属性（按定义顺序调用，优先级一样）

​	②子类的静态代码块和静态属性

​	③父类普通代码块和普通属性初始化

​	④父类构造方法

​	⑤子类的普通代码块和普通属性初始化

​	⑥子类的构造方法

#### &sect;4.单例设计模式

**一、概念**

1、设计模式是在大量的实践中总结和理论化之后优选的代码结构，编程风格、及解决问题的思考方式

2、单例模式：采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，且该类只提供一个取得对象实例的方法。

**二、分类**

饿汉式、懒汉式

**三、实现步骤**

1、饿汉式

​	①构造器私有化。//防止直接New

​	②类的内部创建对象（private static）

​	③向外暴露一个静态的公共方法 getInstance

​	④代码实现

2、懒汉式

​	①构造器私有化

​	②定义一个静态属性对象。//private static Cat cat

​	③提供public static方法，返回一个Cat对象

​	`public staic Cat getInstance(){`

​		`		if (cat==null){`		

​		`		cat=new Cat(...);`		

​	`}`

​	`return cat;`

​	`}`

**四、对比**

1、二者最主要的区别在于创建对象时机不同，饿汉式在类加载时创建，懒汉式在使用时创建

2、饿汉式存在浪费资源的可能，懒汉式存在线程安全问题

#### &sect;5.关键字

**一、基本介绍**

final可修饰类、属性、方法和局部变量

以下情况，须用到final：

1、不希望类被继承

2、不希望父类的某方法被子类覆盖/重写

3、不希望类的某个属性值被修改

4、不希望某局部变量被修改

**二、使用细节**

1、final修饰属性有叫常量，一般用XX_XX命名

2、final修饰的属性在定义时，必须赋初值，且以后不能修改。赋值可以在以下位置：

​	①定义时

​	②构造器

​	③代码块

3、若final修饰静态属性，则在以下位置赋值

​	①定义时

​	②在静态代码块

4、final类不能继承，但可以实例化对象

5、若类不是final类，但含义final方法，则方法虽不能被重写，但可以被继承

6、一般，若一个类已是final类，则没必要再将方法声明为final方法

7、final和static往往搭配使用，效率更高，不会导致类的加载

8、包装类（Integer.Double.Float.Boolean等）都是final类，String也是。

#### &sect;6.抽象类

**一、引入**

当父类的一些方法不确定时，可用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类

**二、语法**

抽象类：访问修饰符 abstrct 类名{...}

抽象方法：访问修饰符 abstract 返回类型 方法名（参数）

**三、细节**

1、抽象类不能被实体化

2、抽象类可以没有abstract方法

3、一旦类包含abstract方法，则此类必须声明为abstract

4、abstract只能修饰类和方法

5、抽象类可以有任意成员

6、抽象方法不能有主体

7、若一个类继承了抽象类，则它必须实现抽象方法，除非它自己也声明为抽象类

8、抽象方法不能使用private.final.static来修饰

#### &sect;7.接口

**一、介绍**

1、接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来

2、语法：

​	interface 接口名{

​	//属性、方法

​	}

​	class 类名 implements 接口{

​	//自己的属性、方法，实现接口的抽象方法

​	}

3、注：jdk7.0前接口里所有方法都是抽象方法；jdk8.0后接口类可以有静态方法、默认方法。默认方法用default关键字修饰

**二、细节**

1、接口不能被实例化

2、接口中所有方法是public方法，接口中抽象方法可以不用abstract修饰，默认公开抽象

3、普通类须将接口中所有方法都实现，抽象类不用

4、一个类可同时实现多个接口

eg: class A implements B,C{...}

5、接口中属性只能是public static final //默认

6、接口中属性的访问：接口名.属性名

7、接口不能继承类，但可以继承多个其他接口

8、接口的修饰符只能是public或默认

**三、实现接口VS.继承类**

1、接口和继承解决的问题不同

接口价值在于：设计各种规范，让其他类实现方法

继承价值在于：解决代码的复用性和可维护性

2、接口比继承更灵活

继承是is-a关系，接口是like-a关系

3、接口在一定程度上实现代码解耦

**四、接口的多态性**

1、多态参数，接口引用可以指向实现接口类的所有对象

2、多态数组，可用instanceof判断运行类型

3、接口存在多态传递现象，接口可指向实现子类接口的类对象

#### &sect;8.内部类

**一、介绍**

一个类的内部又完整嵌套了另一个类结构。被嵌套的类称为内部类，嵌套其他类的类称为外部类。是类的第五大成员。内部类最大特点是可直接访问私有属性，且可体现类与类间的包含关系。

**二、分类**

1、定义在外部类局部位置上（eg.方法内）

​	①局部内部类（有类名）

​	②匿名内部类（没有类名）<font style=background:red>&spades;</font>

2、定义在外部类的成员位置上

​	①成员内部类（没有static修饰）

​	②静态内部类（使用static修饰）

**三、局部内部类**

注：局部内部类是定义在外部类的局部位置，如方法中，且有类名

1、局部类可访问外部类的任意成员

2、不能添加访问修饰符，因为他是局部变量。局部变量不可用修饰符，但可用final修饰

3、作用域：仅在定义它的方法或代码块中

4、局部内部类可直接访问外部类成员

5、外部类访问局部内部类成员须创建对象再访问

6、若外部类和局部内部类的成员重名，默认就近原则，若想访问外部类的成员，则可使用外部类名.this.成员访问

**四、匿名内部类**<font style=background:red>&spades;</font>

注：匿名内部类是定义在外部类的局部位置，如在方法中，且没有类名，它同时也是一个对象。

1、语法：new 类或接口（参数列表）{

​				类体；

​				}

底层会分配名称，为外部类名$X（X为1，2，3...）

2、匿名内部类既是一个类的定义，也是一个对象。故从语法上看，它既有定义类的特征，也有创建对象的特征。

3、当作实参直接传递，简洁高效

**五、成员内部类**

注：成员内部类是定义在外部类的成员位置，且没有static修饰

1、可直接访问外部类的所有成员

2、可添加任意访问修饰符

3、作用域为整个类体

4、外部类访问成员内部类，创对象再访问

5、外部其他类，使用成员内部类

​	①Outer out=new Outer();

​		Outer.Inner in=Outer.new Inner();

​	②在外部类写一个返回Inner对象的方法

​		Outer.Inner in=out.getInner();

​	③Inner in=new Outer().new Inner();

**六、静态内部类**

注：静态内部类定义在外部类的成员位置，且有static修饰

1、可直接访问外部类所有静态成员，但不能直接访问非静态成员

2、可添加任意访问修饰符

3、作用域为整个类体

4、外部其他类访问静态内部类

​	①Outer.Inner in=new Outer.Inner();

​	②编写方法，返回静态实例

5、若外部类和静态内部类成员重名，想访问外部类成员，可使用外部类名.成员访问



<p id="9"></p>



### 第九章：房屋租赁系统

**一、房屋租赁系统框架图（分层模式）**

1、明确系统有哪些类

2、明确类与类之间的调用关系

![hadoop](https://github.com/Vincy-w/my_java_study/raw/main/picture/房屋租赁.png)

（具体实现见代码）



<p id="8"></p>



### 第八章：面向对象编程（中级）

#### &sect; 1.IDEA

**一、IDEA常用快捷键**

删除行：ctrl + y

复制行：ctrl + d

导入改行所需类：alt + enter

快速格式化代码：ctrl + alt + l

查看类的继承关系：ctrl + H

定位方法的源码：ctrl + b

自动分配变量名，在其后加 .var

**二、模板/自定义模板类**

eg: main. fori .sort

自定义：file -> settings -> editor -> Live templates ->



#### &sect; 2.包

**一、作用**

1、区分相同名字的类

2、当类很多时，可以很好的管理类

3、控制访问范围

**二、包基本语法**

`package com.vincy`

注：package 关键字，com.vincy 包名

**三、本质分析**

实际上是创建不同文件夹来保存类文件

**四、包的命名**

1、命名规则：只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能用关键字或保留字

2、命名规范：小写字母 + 小圆点（com.公司名.项目名.业务模块名）

**五、常用的包（java）**

1、java.lang.* //基本包，默认引入

2、java.util.* //系统提供的工具包，工具类，Scanner

3、java.net.* //网络包，网络开发

4、java.awt.* //做java的界面开发

**六、引入包**

语法： import 包

eg: `import java.util.Scanner;`

注：一般使用哪个类，就导入哪个类

**七、使用细节**

1、package的作用是声明当前类所在包，须放在类最上面。一个类中最多有一句package。

2、import命令，位置在package下面，在类定义前，可有多条import语句。



#### &sect; 3.访问修饰符

**一、介绍**

java提供四种访问控制修饰符，用于控制方法和属性的访问权限

1、公开级别：用public修饰，对外公开

2、受保护级别：用protected修饰，对子类和同一包中的类公开

3、默认级别：无修饰符号，向同一包中的类公开

4、私有级别：用private修饰，只有本类可以访问，不对外公开

| 访问级别 | 访问控制修饰符 | 本类 | 同包 | 不同包子类 | 不同包 |
| -------- | -------------- | ---- | ---- | ---------- | ------ |
| 公开     | public         | √    | √    | √          | √      |
| 受保护   | protected      | √    | √    | √          | ×      |
| 默认     | 无修饰符       | √    | √    | ×          | ×      |
| 私有     | private        | √    | ×    | ×          | ×      |

**二、注意事项**

1、修饰符可以用来修饰类中的属性，成员方法以及类

2、只有默认和public方法可修饰类



#### &sect; 4.封装

**一、介绍**

封装（encapsulation）就是把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（方法），才能对数据进行操作。

**二、好处**

1、隐藏实现细节

2、可对数据进行验证，保证安全合理

**三、实现步骤**

1、将属性私有化

2、提供一个公共的set、get方法，用于设置和获取属性的值



#### &sect; 5.继承

**一、介绍**

继承可以解决代码复用，让我们的编程更加靠近人类思维。当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同属性和方法，所有子类不需要重新定义，只需要extends声明继承。

**二、基本语法**

`class 子类 extends 父类 {}`

1、子类会自动拥有父类的属性和方法

2、子类又叫派生类

**三、好处**

1、代码复用性很高

2、代码扩展性、维护性提高

**四、细节**

1、子类继承所有属性和方法，但私有属性和方法不能在子类直接访问，要通过公共方法访问

2、子类必须调用父类的构造器，完成父类的初始化

3、创建子类对象时，不管使用子类哪个构造器，默认调用父类无参构造器，若父类未提供无参构造器，则须在子类构造器中用super指定使用父类哪个构造器

4、super在使用时，须放在构造器第一行

5、super()和this()都必须放在构造器第一行，故这两个方法不能共存于同一构造器

6、java中所有类都是Object的子类

7、子类最多只能继承一个父类（直接继承）

8、不能滥用继承，子类和父类必须满足is-a逻辑

**五、本质**

1、先在方法区加载类，从父类加载到子类

2、在堆中分配内存，加载各类的信息，从父类加载到子类

3、将堆中地址赋给栈中类名



#### &sect; 6.super关键字

**一、介绍**

super代表父类的引用，用于访问父类的属性、方法、构造器

**二、基本语法**

1.访问父类属性：super.属性名；

2.访问父类方法：super.方法名(参数列表)；

3.访问父类构造器：super(参数列表)；（只能放在构造器第一句）。

**三、细节**

1.若子类中有和父类中成员重名，则须通过super访问父类成员

2.super的访问不限于直接父类，若爷类和本类中有同名成员，也可用super去访问爷类成员；若多个上级类中都有同名成员，使用super访问遵循就近原则。

**四、super和this比较**

| No.  |   区别点   |                      this                      |                super                 |
| :--: | :--------: | :--------------------------------------------: | :----------------------------------: |
|  1   |  访问属性  |     访问本类属性，若无此属性，则从父类查找     |          从父类开始查找属性          |
|  2   |  调用方法  | 访问本类中的方法，若本类没有，则从父类继续查找 |            从父类开始查找            |
|  3   | 调用构造器 |        调用本类构造器，须放在构造器首行        | 调用父类构造器，须放在子类构造器首行 |
|  4   |    特殊    |                   表当前对象                   |          子类中访问父类对象          |



#### &sect; 7.方法重写（override）

**一、介绍**

指子类有一个方法，和父类某方法名称、返回类、参数一样，则我们说子类的这个方法覆盖了父类的方法。

**二、注意事项**

1.子类的方法的参数、名称，要和父类方法的参数、名称完全一致。

2.子类的方法的返回类型和父类方法的返回类型一致，或是父类返回类型的子类。（eg.父类返回Object，子类返回String）

3.子类方法不能缩小父类方法的访问权限，但可以放大

**三、重载、重写的比较**

|                  | 发生范围 | 方法名 |           形参列表           |          返回类型          |               修饰符               |
| :--------------: | :------: | :----: | :--------------------------: | :------------------------: | :--------------------------------: |
| 重载（overload） |   本类   |  一样  | 类型、个数、顺序至少一个不同 |           无要求           |               无要求               |
| 重写（override） |  父子类  |  一样  |             一样             | 子类须和父类一致或是其子类 | 子类方法不能缩小父类方法的访问范围 |



#### &sect; 8.多态（polymorphic）

**一、介绍**

方法或对象有多种形态，是面向对象的第三大特征，多态是建立在封装和继承上的。

**二、多态的具体体现**

1.方法的多态，如重写、重载

2.对象的多态 <font style=background:red>&spades;&spades;</font>

​	（1）一个对象的编译类型和运行类型可以不一致  eg.Animal ani = new Dog(); //编译类型是Animal，运行类型是Dog

​	（2）编译类型在定义对象时，就确定了，不能改变

​	（3）运行类型可变化 eg. ani = new Cat(); //ani的运行类型变成Cat

​	（4）编译类型看定义时“=”左边，运行类型看“=”右边，可用getClass()方法获得运行类型

**三、注意事项**

1.多态的前提是两个类存在继承关系

2.本质：父类的引用指向子类的对象（向上转型）

3.语法：父类类型 引用名 = new 子类类型（）；

4.可以调用父类的所有成员，但不能调用子类特有成员（遵循访问权限）

5.最终运行效果看子类具体实现，即调用时，按从子类开始查找的规则

6.向下转型

​	（1）语法： 子类类型 引用名 = （子类类型）父类引用；

​	（2）只能强转父类的引用，不能强制父类的对象

​	（3）要求父类的引用必须指向当前目标类型的对象

​	（4）可以调用子类类型中所有成员

7.属性没有重写之说，属性的值看编译类型

8.instanceof比较操作符，用于判断对象的运行类型是否为XX类型或其子类型

**四、Java的动态绑定机制（Dynamic Binding）**

1.当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定

2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

**五、多态的应用**

1.多态数组：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型

2.多态参数：方法定义的形参类型为父类类型，实参类型允许为子类类型



#### &sect; 9.Object类详解

**一、equals方法**

1.== 和equals对比

​	&diams; ==是一个比较运算符

​	（1）==：既可以判断基本类型，又可以判断引用类型

​	（2）==：若判断基本类型，判断的是值是否相等

​	（3）==：若判断引用类型，判断的是地址是否相等

​	&diams; equals方法：是Object类中的方法，只能判断引用类型

2.equals重写

**二、hashCode方法**

1.返回该对象的哈希码值，提高具有哈希结构的容器的效率

2.两个引用，若指向同一个对象，则哈希值肯定一样

3.两个引用，若指向不同对象，则哈希值不一样

4.哈希值主要根据地址而来，但不能完全将哈希值等价于地址

5.后面集合中，如需要，hashCode也会重写

**三、toString()方法**

1.介绍：默认返回：全类名+@+哈希值的十六进制

2.子类往往重写toString方法，用于返回对象的属性信息

3.直接输出一个对象时，toString方法会被默认调用

​	eg.System.out.printlin(monster); //默认调用monster.toString()

**四、finalize()方法**

1.当对象被收回时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作

2.何时被回收：当某对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，在销毁该对象前，会先调用finalize方法

3.垃圾回收机制调用，是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制



#### &sect; 10.断点调试

**一、需求**

1.发现源码的错误

2.在断点调试中，以对象的运行类型来执行

**二、介绍**

1.断点调试是指在程序的某行设置一断点，调试时，程序的运行到此行停止。然后可以一步步向下调试，调试过程中可看到各个变量当前值。若有错，调试到出错行即显示错误，停止。

2.断点调试能查看java底层源代码的执行过程

**三、快捷键**

F7：跳入方法内

F8：逐行执行代码

shift+F8：跳出方法

F9：执行到下一个断点（debug执行中，可动态下断点）



<p id="7"></p>



### 第七章：面向对象编程（初级）

#### &sect; 1.类与对象

类是数据类型，对象是一个具体的实例

**一、类和对象区别**

1.类是抽象的、概念的，代表一类事物

2.对象是具体的、实际的，代表一个具体事物

3.类是对象的模板，对象是类的个体

**二、属性/成员变量**

1.介绍

​	（1）从概念或叫法上看，成员变量 = 属性 = field

​	（2）属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型

2.注意事项

​	（1）属性的定义语法同变量

​	（2）属性若不赋值，有默认值

3.类也是引用类型

**三、类和对象内存分配机制**

1.Java内存的结构分析

​	（1）栈：一般存放基本数据类型（局部变量）

​	（2）堆：存放对象、数组等

​	（3）方法区：常量池（常量，如字符串），类加载信息

2.Java创建对象的流程简单分析

​	（1）先加载类信息（属性和方法信息，只会加载一次）

​	（2）在堆中分配空间，进行默认初始化

​	（3）把地址赋给对象名



#### &sect; 2.成员方法

**一、介绍**

在某些情况下，须定义成员方法。如人类：除属性外（age.name...），还有一些行为如：speak.run...

**二、必要性**

1.提高代码的复用性

2.可将实用的细节封装起来，然后供其他用户调用

**三、定义**

访问修饰符 返回数据类型 方法名（形参列表...）{

​	//方法体

​	return 返回值

}

**四、注意事项**

1.访问修饰符：public protected 默认 private 

2.一个方法最多有一个返回值，若需要返回多个结果，可返回数组

3.方法名遵循驼峰法，eg. getSum

4.方法体中写完成功能的具体语句，但方法中不能再定义方法

5.方法调用，在同类中直接调用即可；跨类调用，须通过对象名



#### &sect; 3.成员方法传参机制

**一、基本数据类型的传参机制**

形参的任何变化不影响实参

**二、引用数据类型的传参机制**

引用类型传递的地址，可以通过形参影响实参



#### &sect; 4.递归

**一、规则**

1.执行一个方法时，就创建一个新的受保护的独立空间

2.方法的局部变量独立，不会互相影响

3.若方法中使用的是引用类型变量，就共享该引用类型数据



#### &sect; 5.方法重载

**一、介绍**

java中允许同一类中，多个同名方法存在，但要求形参列表不一样。这样减轻了起名、记名的麻烦。

**二、使用细节**

1.方法名：必须相同

2.参数列表：必须不同（参数类型、个数或顺序至少有一样不同）

3.返回值：无要求



#### &sect; 6.可变参数

**一、基本概念**

java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法

**二、基本语法**

访问修饰符 返回类型 方法名（数据类型... 形参名）{}

eg. 求两个/三个/四个... 数的和

public int sum (int... nums){//求和}

**三、注意事项**

1.可变参数的实参可以为0个或任意多个

2.可变参数的实参可为数组

3.可变参数的本质就是数组

4.可变参数可以和普通类型的参数一起放在形参列表中，但必须保证可变参数在最后

5.一个形参列表中只能出现一个可变参数



#### &sect; 7.作用域（Scope）

**一、基本使用**

1.在java中，主要变量为属性和局部变量

2.局部变量一般指在成员方法中定义的变量

3.分类：全局变量：即属性，作用域为整个类体

​			   局部变量：除属性外的变量

4.全局变量可以不赋值，直接使用默认值。

   局部变量赋值后才能使用，无默认值。

**二、使用细节**

1.属性和局部变量可以重名，访问时遵循就近原则

2.属性生命周期较长，伴随对象的创建而创建，伴随对象销毁而销毁。局部变量，生命周期较短，伴随代码块的执行而创建，随代码块结束而销毁

3.全局变量（属性）可以加修饰符，局部变量不能加修饰符



#### &sect; 8.构造器/构造方法

**一、基本语法**

修饰符 方法名（形参列表）{//方法体}

注：（1）无返回值，也不能写出void

​		（2）构造器的调用由系统自动完成

**二、基本介绍**

构造器/构造方法，是类的一种特殊方法，主要作用是完成对新对象的初始化。

**三、使用细节**

1.一个类可定义多个不同构造器，即构造器重载

2.一旦定义了自己的构造器，默认的构造器就覆盖了，若要使用须显式定义

**四、对象创建流程**（<font color=Red>&spades;&spades;</font>）

1.在方法区加载类信息，仅一次

2.在堆中分配空间

3.完成对象初始化

4.把对象在堆中的地址返回给对象名



#### &sect; 9.关键字this

**一、定义**

java虚拟机会给每个对象分配this，代表当前对象，即哪个对象调用，this就代表哪个对象

**二、使用细节**

1.this关键字可用来访问本类的属性、方法、构造器

2.this用于区分当前类的属性和局部变量

3.访问构造器：this(参数列表)，只能在构造器中访问另一个构造器，且this(...)必须放在第一条语句

4.this只能在类定义内部使用



<p id="6"></p>



### 第六章：数组、排序、查找

#### &sect; 1.数组

**一、介绍**

可以存放多个同一类型的数据，是引用类型。

**二、使用**

1、法1——动态初始化

​	定义：数据类型[] 数组名 = new 数据类型[大小]；

​	eg:`int a[] = new int[5];`

2、法2——动态初始化

​	先声明：数据类型[] 数组名；

​	再创建：数组名 = new 数据类型[大小]；

​	eg:`int[] a;`

​		`a = new int[5];`

3、法3——静态初始化

​	语法：数据类型[] 数组名 = {元素值，元素值，……}

**三、注意事项**

1、数组创建后，若未赋值，有默认值

2、数组属于引用类型，数组型数据是对象

**四、数组赋值机制**

1、基本数据类型，赋值方式为值拷贝

2、数组在默认情况下是引用传递，赋的值是地址

#### &sect; 2.排序

**一、介绍**

排序是将多个数据，依指定顺序进行排序的过程

**二、排序的分类**

1、内部排序

​	指将需要处理的所有数据都加载到内部存储器中进行排序。包括交换式排序，选择式排序，插入式排序法。

2、外部排序

​	数据量过大，无法全部加载到内存中，须借助外部存储进行排序。包括合并排序法和直接合并排序法。

**三、冒泡排序**

基本思想：通过对待排序序列从后向前，依次比较相邻元素的值，若发现逆序则交换。（代码示例BubbleSort.java）

#### &sect; 3.查找

**一、介绍**

常用两种：顺序查找、二分查找

#### &sect; 4.多维数组

**一、二维数组**

1、静态定义：`int[][] arr = {{1,2,3},{...},{...}}`

​	遍历：```for (int i = 0; i < arr.length; i++){```

​						`for(int j = 0; j < arr[i].length); j++){}}`

2、动态初始化

​	（1）语法：`类型[][] 数组名 = new 类型[大小][大小]`

​	（2）先声明、再定义

​	（3）列数不确定（Java中允许二维数组中的一维数组元素个数不同，代码示例：TwoDimenArray02.java）

3、使用细节

​	声明方式：`int[][] y; 或 int[] y[]; 或 int y[][];`



<p id="5"></p>



### 第五章：程序控制结构

#### &sect; 1.顺序控制

程序以从上至下逐行地执行，中间无任何判断、跳转

#### &sect; 2.分支控制

**一、if-else**

让程序有选择的执行：分为单分支、双分支、多分支。且最多只有一个执行入口。

**二、嵌套分支**

在一个分支结构中又完整嵌套了另一个完整分支结构，里面的分支结构成为内层分支，外面的分支结构称为外层分支。规范：一般不超过三层。

**三、switch分支**

1、基本语法

`switch(表达式){`

`	case 常量1：语句块1;break;`

`	case 常量2：语句块2;break;`

`...`

`	case 常量n：语句块n;break;`

`default:default语句块;break;`

`}`

2、流程

![pic](https://github.com/Vincy-w/my_java_study/raw/main/picture/switch流程.png)

3、注意事项

​	（1）表达式数据类型应和case后常量类型一致，或它们可自动转换为可相互比较的类型

​	（2）switch（表达式）中返回值类型必须为byte/short/int/char/enum(枚举)/String

​	（3）case中的值只能是常量不能是变量

​	（4）default语句可选

#### &sect; 3.循环控制

**一、for循环控制**

1、语法

`for(循环变量初始化;循环条件;循环变量迭代){`

​	`循环操作;`

`}`

2、注意事项

​	（1）循环条件会返回一个布尔值

​	（2）循环初始值可有多条初始化语句，但要求类型一样，中间用逗号隔开。循环变量迭代同理。

**二、while循环控制**

1、语法

`循环变量初始化;`

`while(循环条件){`

​	`循环体;`

​	`循环变量迭代;`

`}`

**三、do...while循环控制**

1、语法

`循环变量初始化;`

`do{`

​	`循环体;变量迭代;	//先执行再判断，至少执行一次`

`}while(循环条件);`

**四、多重循环控制**

将一个循环放在另一个循环体内，就形成嵌套循环（一般最多不超3层）

#### &sect; 4.跳转控制语句——break

**一、break介绍**

用于终止某个语句块的执行，一般用于switch和循环语句

**二、细节**

1、break语句出现在多层嵌套语句块中时，可通过标签指明要终止的是哪层语句块

2、标签基本使用

`label1:{...`

`label2:		{...`

`label3:			{...`

`												break label2;`

`}}}`

注：（1）label1是标签，名字由程序员指定

​		（2）实际开发中，尽量不使用标签

​		（3）若未指定标签，默认退出最近的循环体

#### &sect; 5.跳转控制语句——continue

**一、介绍**

1、continue用于结束本次循环，执行下一次循环

2、可使用标签，方法同break

#### &sect; 6.跳转控制语句——return

**一、介绍**

return使用在方法，表跳出所在方法。若return写在main方法中，则退出程序。



<p id="4"></p>



### 第四章：运算符

#### &sect; 1.运算符介绍

**一、介绍：**运算符是一种特殊符号，用以表示数据的运算、赋值和比较等。

#### &sect; 2.算数运算符

**一、介绍：**对数值类型变量进行运算

**二、使用**

​	1、取模%：本质是a % b = a - ((int)a/b) * b

#### &sect; 3.关系运算符（比较运算符）

**一、介绍：**比较结果为boolean型，只能是true或false

**二、细节：**字符串内容进行比较时，不能用“==”，应如下比较

​					`String name = "wang";	"wang".equals(name);`

#### &sect; 4.逻辑运算符

**一、介绍：**用于连接多个关系表达式，结果也为boolean值

**二、运算符一览：**a & b (逻辑与)，a && b (短路与)，a | b (逻辑或) ，a || b (短路或) ，!a (取反) ，a ^ b (逻辑异或，a.b不同时，结果为								true，否则为false)

注：赋值语句作为判断条件时，以所赋值为判断条件

#### &sect; 5.赋值运算符

**一、介绍：**将某个运算后的值，赋给指定变量

**二、分类**

​	1、基本赋值运算符 =

​	2、复合赋值运算符 += 、-= 、*= 、/= 、%=

**三、特点**

​	1、运算顺序从右向左

​	2、复合赋值运算符会进行类型转换，例如 `byte b = 3; b += 2;	//等价于 b = (byte)(b + 2);`

#### &sect; 6.三元运算符

**一、基本语法**

​	条件表达式 ？表达式1：表达式2；

​	规则：条件表达式为true，运算后结果为表达式1；条件表达式为false，运算后结果为表达式2

#### &sect; 7.位运算

**一、进制**

1、介绍：（1）二进制：以0b或0B开头

​				  （2）十进制

​				  （3）八进制：以0开头

​				  （4）十六进制：以0x或0X开头，由0-9以及A（10）- F（15）组成，此处A-F不区分大小写

2、进制的转换

​	（1）其他转十进制

​		二转十：从最低位始，将每位上的数提出，乘以2的（位数-1）次方，再求和

​		八转十：从最低位始，将每位上的数提出，乘以8的（位数-1）次方，再求和

​		十六转十：从最低位始，将每位上的数提出，乘以16的（位数-1）次方，再求和

​	（2）十进制转其他

​		十转二：将该数不断除以2，直至商为0，再将所有余数倒过来，则为对应二进制

​		十转八：将该数不断除以8，直至商为0，再将所有余数倒过来，则为对应八进制

​		十转十六：将该数不断除以16，直至商为0，再将所有余数倒过来，则为对应十六进制

​	（3）二进制转八、十六

​		二转八：从低位始，将二进制数每三位一组，转成对应八进制数

​		二转十六：从低位始，将二进制数每四位一组，转成对应十六进制数

​	（4）8、16转二进制

​		八转二：将八进制每位转成一个3位二进制数

​		十六转二：将十六进制每位转成一个4位二进制数

**二、原码、反码、补码**

1、二进制最高位是符号位：0表示正数，1表示负数

2、正数的原码、反码、补码都一样

3、负数的反码是原码的符号位不变，其他位取反

4、负数的补码 = 它的反码 + 1

​	  负数的反码 = 它的补码 - 1

5、0的反码、补码都是0

6、java没有无符号数

7、计算机运算时，均以补码的方式来运算

8、看运算结果时，要看其原码

**三、位运算符**

1、&（按位与）：两个全为1，结果为1，否则为0

2、|（按位或）：两位有一个为1，则为1，否则为0

3、^（按位异或）：两位不同，则为1，否则为0

4、~（按位取反）：0->1，1->0

5、>>（算术右移）：低位溢出，符号位不变，用符号位补溢出的高位

6、<<（算术左移）：符号位不变，低位补0

7、>>>（无符号右移）：低位溢出，高位补0	<font color = grey>注：没有<<<符号</font>



<p id="3"></p>



### 第三章：变量

#### &sect; 1.变量介绍

##### 一、定义

​	变量是程序的基本组成单位。变量相当于内存中一个数据存储空间的表示。

##### 二、注意事项

​	1、变量先声明，后使用。

​	2、变量三要素：变量名、值、数据类型

#### &sect; 2.加号使用

##### 一、方法

​	1、左右两边为数值，做加法

​	2、当左右有一方为字符串，则做拼接运算

​	3、运算从左至右

#### &sect; 3.数据类型

![pic](https://github.com/Vincy-w/my_java_study/raw/main/picture/数据类型.png)

##### 一、整型使用

​	1、Java整型默认为int，声明long型须在后面加“l“或”L“

​	2、1byte = 8bits

##### 二、浮点

​	1、浮点数 = 符号位 + 指数位 + 尾数位

​	2、Java浮点默认为double型，声明float时须在后面加”f”或“F”

​	3、浮点数表示：0.512 = .512

​		  科学计数：5.12e2(5.12×10^2)，5.12e-2(5.12×10^-2)

​	4、浮点数使用陷阱：2.7 ≠ 8.1/3

##### 三、字符类型

​	1、简介：表示单个字符

​	2、Java中char的本质是一个整数，输出时，为Unicode对应字符

​	3、字符类存储时，将字符对应码值找出，再转为二进制存储

​	 	 <font color = gray>eg.存：‘a’ => 97 => 二进制 =>存</font>

##### 四、布尔类

​	只能为true或false，不能用0或非0整数替代

#### &sect; 4.基本数据类型转换

##### 一、自动类型转换

​	1、精度小的可自动转换为精度大的数据类型

​	2、精度大小排序

​		char -> int ->long -> float -> double

​		byte -> short -> int -> long -> float -> double

​	3、注意细节：（1）（byte、short）和char之间不能自动转换

​							 （2）byte、short、char三者可以计算，计算时首先转为int

##### 二、强制类型转换

​	1、语法：在变量前加：“ (要变的数据类型) ”

​	2、char可保存int常量值，但不能存int变量值

##### 三、基本数据类型和String类型的转换

​	1、基本数据类型转为String类型

​		 语法：给基本类型值加 “ ”即可。如： `int n1 = 100; String s1 = n1 + " ";`

​	2、String类型转基本数据类型

​		 语法：通过基本类型的包装类调用parseXX方法即可。如下：

​		 `Integer.parseInt("123");`

​		 `Double.parseDouble("12.3");`

​		 `Float.parseFloat("12.3");`



<p id="2"></p>



### 第二章：Java代码规则与规范

##### 一、规则

（一）注意事项

​		1、Java源文件以 .java为扩展名，源文件的基本组成部分是类（class）。

​		2、Java应用程序的执行入口是main()，有固定书写格式`public static void main(String[] args){ }`

​		3、Java严格区分大小写			

​		4、一个源文件中最多一个Public类，其他不限

​		5、源文件名须与public类名保持一致

（二）常用转义字符

​		1、`\t`：制表位

​		2、`\n`：换行

​		3、`\\`：一个\

​		4、`\"`：一个“

​		5、`\'`一个’

​		6、`\r`一个回车

（三）注释

​		1、单行注释：`//.....`

​		2、多行注释：`/*`

​											`.........`

​									`*/`  

（四）标识符命名规则

​		1、由大小写字母，0-9，_ 或 $组成

​		2、数字不能开头

​		3、不能使用关键字或保留字，但可包含

​		4、标识符不能含空格

（五）键盘输入

​		1、引入Scanner类所在包 `import java.util.Scanner;`

​		2、创建Scanner对象 `Scanner sc = new Scanner(System.in);`

​		3、接受用户的输入，使用相关方法，如下：

​				`String name = sc.next();`

​				`int age = sc.nextInt();`

​				`char gender = sc.next().charAt(0);`

##### 二、规范

（一）注意事项

​		1、运算符两边习惯各加一个空格

​		2、源文件应设为utf-8模式

​		3、代码编写此行风格或行尾风格

（二）标识符命名规范

​		1、包名：多单词组成时对所以字母都小写，如：aaa.bbb

​		2、类名、接口名：多单词组成时所有单词首字母大写，如：TankShotGame

​		3、变量名、方法名：多单词组成时，第一个单词首字母小写，其后单词首字母大写，如：tankShotGame

​		4、常量名：所有字母大写，多单词用下划线连接，如：TAX_RATE



<p id="1"></p>



### 第一章：概述

##### 一、特点

​	1、Java具有跨平台性。

​	2、Java语言是解释性的。

​	3、Java是面向对象的。

##### 二、Java开发工具

​	IDEA、eclipse、sublime......

##### 三、Java虚拟机（JVM）

​	1、JVM包含在JDK中

​	2、不同平台有不同版本JVM

​	3、JVM屏蔽了底层运行平台的差别

##### 四、JDK简介

​	1、JDK全称Java开发工具包

​		JDK = JRE + java开发工具

​	2、JRE（Java运行环境）

​		JRE = JVM + java核心类库

##### 五、执行流程

​	.java 源文件 —javac编译—> .class字节码文件 —java运行—> 结果